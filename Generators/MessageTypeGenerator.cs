using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Ubicomp.Utils.NET.Generators
{
    [Generator]
    public class MessageTypeGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var messages = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: (s, _) => IsCandidate(s),
                    transform: (ctx, _) => GetMessageInfo(ctx))
                .Where(m => m != null);

            var compilation = context.CompilationProvider.Combine(messages.Collect());

            context.RegisterSourceOutput(compilation, (spc, source) => Execute(spc, source.Left, source.Right));
        }

        private static bool IsCandidate(SyntaxNode node)
        {
            // Look for ClassDeclaration with Attributes
            return node is ClassDeclarationSyntax c && c.AttributeLists.Count > 0;
        }

        private static MessageTypeInfo? GetMessageInfo(GeneratorSyntaxContext context)
        {
            var classDeclaration = (ClassDeclarationSyntax)context.Node;
            var symbol = context.SemanticModel.GetDeclaredSymbol(classDeclaration);

            if (symbol is not ITypeSymbol typeSymbol)
                return null;

            // Find valid Attribute using name check (to avoid hard dependency match if possible, or use full name)
            var attr = typeSymbol.GetAttributes()
                .FirstOrDefault(ad => ad.AttributeClass?.Name == "MessageTypeAttribute" ||
                                      ad.AttributeClass?.ToDisplayString() == "Ubicomp.Utils.NET.MulticastTransportFramework.MessageTypeAttribute");

            if (attr == null)
                return null;

            string? msgId = attr.ConstructorArguments.FirstOrDefault().Value?.ToString();

            if (string.IsNullOrEmpty(msgId))
                return null;

            return new MessageTypeInfo
            {
                FullTypeName = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                MessageId = msgId
            };
        }

        private static void Execute(SourceProductionContext context, Compilation compilation, System.Collections.Immutable.ImmutableArray<MessageTypeInfo?> messages)
        {
            if (messages.IsDefaultOrEmpty)
                return;

            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("using System;");
            sb.AppendLine("using Ubicomp.Utils.NET.MulticastTransportFramework;");
            sb.AppendLine();
            sb.AppendLine("namespace Ubicomp.Utils.NET.Generators.AutoDiscovery");
            sb.AppendLine("{");
            sb.AppendLine("    public static class TransportExtensions");
            sb.AppendLine("    {");
            sb.AppendLine("        /// <summary>");
            sb.AppendLine("        /// Registers all message types discovered by Source Generator.");
            sb.AppendLine("        /// </summary>");
            sb.AppendLine("        public static void RegisterDiscoveredMessages(this TransportComponent component)");
            sb.AppendLine("        {");

            foreach (var msg in messages.Distinct()) // Remove duplicates if partial classes etc
            {
                if (msg == null)
                    continue;
                sb.AppendLine($"            component.RegisterMessageType<{msg.FullTypeName}>(\"{msg.MessageId}\");");
            }

            sb.AppendLine("        }");
            sb.AppendLine("    }");
            sb.AppendLine("}");

            context.AddSource("TransportExtensions.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
        }

        private class MessageTypeInfo : System.IEquatable<MessageTypeInfo>
        {
            public string? FullTypeName
            {
                get; set;
            }
            public string? MessageId
            {
                get; set;
            }

            public bool Equals(MessageTypeInfo? other)
            {
                if (other is null)
                    return false;
                return FullTypeName == other.FullTypeName && MessageId == other.MessageId;
            }

            public override bool Equals(object? obj)
            {
                return obj is MessageTypeInfo info && Equals(info);
            }

            public override int GetHashCode()
            {
                unchecked
                {
                    int hash = 17;
                    hash = hash * 23 + (FullTypeName?.GetHashCode() ?? 0);
                    hash = hash * 23 + (MessageId?.GetHashCode() ?? 0);
                    return hash;
                }
            }
        }
    }
}
